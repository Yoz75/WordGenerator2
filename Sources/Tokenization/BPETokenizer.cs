using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WG2.Tokenization
{
    /// <summary>
    /// Byte Pair Encoding (BPE) tokenizer.
    /// (This was generated by GPT-4o, so this may contain some bugs)
    /// </summary>
    public class BPETokenizer : ITokenizer
    {
        private struct Pair
        {
            public string Left, Right;

            public Pair(string left, string right)
            {
                Left = left;
                Right = right;
            }

            public string Build() => Left + Right;

            public static bool operator ==(Pair left, Pair right)
            {
                return left.Left == right.Left && left.Right == right.Right;
            }

            public static bool operator !=(Pair left, Pair right)
            {
                return !(left == right);
            }

            public override int GetHashCode()
            {
                return Build().GetHashCode();
            }
        }

        public DirectedGraph<Token> Tokenize(TokenizerSettings settings, string input)
        {
            DirectedGraph<Token> graph = new DirectedGraph<Token>(settings.ResultCapacity);
            Dictionary<Pair, int> tokenPairFrequencies = new();
            Dictionary<string, Token> tokens = new Dictionary<string, Token>();

            List<List<Token>> resultRawTokens = new();

            if(input.Length % 2 != 0)
            {
                input += " "; // padding for even length
            }

            List<string> initialTokens = input.ToCharArray()
                .Select(c => c.ToString()).ToList();

            for(int i = 0; i < settings.MinimalTokenSize; i++)
            {
                tokenPairFrequencies.Clear();

                for(int j = 0; j < initialTokens.Count; j++)
                {
                    if(j >= initialTokens.Count - 1) break;

                    string left = initialTokens[j];
                    string right = initialTokens[j + 1];

                    if(resultRawTokens.Count <= j)
                    {
                        resultRawTokens.Add(new List<Token>());
                    }
                    resultRawTokens[j].Add(new(left));

                    if(resultRawTokens.Count <= j + 1)
                    {
                        resultRawTokens.Add(new List<Token>());
                    }
                    resultRawTokens[j + 1].Add(new(right));

                    Pair pair = new Pair(left, right);

                    if(left.Length + right.Length > settings.MaximalTokenSize &&
                        !tokenPairFrequencies.ContainsKey(pair)) continue;


                    if(!tokenPairFrequencies.ContainsKey(pair))
                    {
                        tokenPairFrequencies[pair] = 1;
                    }
                    else tokenPairFrequencies[pair]++;
                }

                Pair mostFrequentPair = default;

                KeyValuePair<Pair, int> mostFrequentPairKvp = default;

                foreach(var kvp in tokenPairFrequencies)
                {
                    if(kvp.Value > mostFrequentPairKvp.Value)
                    {
                        mostFrequentPairKvp = kvp;
                    }
                }

                //We don`t have any pair that is more frequent than others
                if(mostFrequentPairKvp.Key == default) continue;
                else mostFrequentPair = mostFrequentPairKvp.Key;

                string mostFrequentPairString = mostFrequentPair.Build();

                for(int k = 0; k < initialTokens.Count - 1;)
                {
                    if(initialTokens[k] + initialTokens[k + 1] == mostFrequentPairString)
                    {
                        initialTokens[k] = mostFrequentPairString;
                        initialTokens.RemoveAt(k + 1);
                    }
                    else
                    {
                        k++;
                    }
                }

                if(settings.LogDebugInfo)
                {
                    foreach(var token in initialTokens)
                    {
                        Logger.LogDebug($"Token: {token}");
                    }
                    Logger.LogDebug("--------------------");
                }
            }

            GenerateTokens(graph, resultRawTokens);

            return graph;
        }

        private static void GenerateTokens(DirectedGraph<Token> graph, List<List<Token>> tokens)
        {
            for(int i = 0; i < tokens.Count; i++)
            {
                foreach(var token in tokens[i])
                {
                    if(i >= tokens.Count - 1) break;

                    foreach(var nextToken in tokens[i + 1])
                    {
                        graph.AddEdge(token, nextToken);
                    }
                }
            }
        }
    }
}